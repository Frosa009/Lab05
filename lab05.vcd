$date
	Mon Mar 20 00:28:16 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module processor_tb $end
$var wire 32 ! write_reg_data [31:0] $end
$var wire 5 " write_reg_addr [4:0] $end
$var wire 32 # reg2_data [31:0] $end
$var wire 5 $ reg2_addr [4:0] $end
$var wire 32 % reg1_data [31:0] $end
$var wire 5 & reg1_addr [4:0] $end
$var wire 32 ' prog_count [31:0] $end
$var wire 6 ( instr_opcode [5:0] $end
$var reg 1 ) clk $end
$var reg 1 * rst $end
$var integer 32 + passedTests [31:0] $end
$var integer 32 , totalTests [31:0] $end
$scope module uut $end
$var wire 1 - branch_zero $end
$var wire 1 ) clk $end
$var wire 1 * rst $end
$var wire 1 . zero $end
$var wire 32 / write_reg [31:0] $end
$var wire 5 0 writeReg2 [4:0] $end
$var wire 5 1 writeReg1 [4:0] $end
$var wire 32 2 reg_write_data [31:0] $end
$var wire 1 3 reg_write $end
$var wire 1 4 reg_dst $end
$var wire 32 5 read_data2 [31:0] $end
$var wire 32 6 read_data1 [31:0] $end
$var wire 32 7 pc_add_4 [31:0] $end
$var wire 32 8 pcO [31:0] $end
$var wire 32 9 pcI [31:0] $end
$var wire 1 : mem_write $end
$var wire 1 ; mem_to_reg $end
$var wire 32 < mem_data [31:0] $end
$var wire 32 = instr [31:0] $end
$var wire 32 > imme [31:0] $end
$var wire 32 ? branch_addr [31:0] $end
$var wire 1 @ branch $end
$var wire 32 A alusrc_mux [31:0] $end
$var wire 1 B alu_src $end
$var wire 32 C alu_result [31:0] $end
$var wire 4 D alu_out [3:0] $end
$var wire 2 E alu_op [1:0] $end
$var reg 6 F instr_opcode [5:0] $end
$var reg 32 G prog_count [31:0] $end
$var reg 5 H reg1_addr [4:0] $end
$var reg 32 I reg1_data [31:0] $end
$var reg 5 J reg2_addr [4:0] $end
$var reg 32 K reg2_data [31:0] $end
$var reg 5 L write_reg_addr [4:0] $end
$var reg 32 M write_reg_data [31:0] $end
$scope module PC $end
$var wire 1 ) clk $end
$var wire 1 * rst $end
$var wire 1 N write_en $end
$var wire 32 O data_in [31:0] $end
$var reg 32 P data_out [31:0] $end
$upscope $end
$scope module Register $end
$var wire 1 ) clk $end
$var wire 32 Q read_data_1 [31:0] $end
$var wire 32 R read_data_2 [31:0] $end
$var wire 5 S read_register_1 [4:0] $end
$var wire 5 T read_register_2 [4:0] $end
$var wire 1 * rst $end
$var wire 5 U write_register [4:0] $end
$var wire 32 V write_data [31:0] $end
$var wire 1 3 reg_write $end
$var integer 32 W i [31:0] $end
$upscope $end
$scope module alu $end
$var wire 32 X channel_a_in [31:0] $end
$var wire 32 Y channel_b_in [31:0] $end
$var wire 4 Z alu_control_in [3:0] $end
$var reg 32 [ alu_result_out [31:0] $end
$var reg 32 \ temp [31:0] $end
$var reg 1 . zero_out $end
$upscope $end
$scope module alu_branch $end
$var wire 4 ] alu_control_in [3:0] $end
$var wire 32 ^ channel_b_in [31:0] $end
$var wire 32 _ channel_a_in [31:0] $end
$var reg 32 ` alu_result_out [31:0] $end
$var reg 32 a temp [31:0] $end
$var reg 1 b zero_out $end
$upscope $end
$scope module alu_control $end
$var wire 6 c instruction_5_0 [5:0] $end
$var wire 2 d alu_op [1:0] $end
$var reg 4 e alu_out [3:0] $end
$upscope $end
$scope module control_unit $end
$var wire 6 f instr_op [5:0] $end
$var reg 2 g alu_op [1:0] $end
$var reg 1 B alu_src $end
$var reg 1 @ branch $end
$var reg 1 h mem_read $end
$var reg 1 ; mem_to_reg $end
$var reg 1 : mem_write $end
$var reg 1 4 reg_dst $end
$var reg 1 3 reg_write $end
$upscope $end
$scope module instr_mem_data_mem $end
$var wire 1 ) clk $end
$var wire 8 i data_address [7:0] $end
$var wire 1 : data_mem_write $end
$var wire 32 j data_read_data [31:0] $end
$var wire 32 k data_write_data [31:0] $end
$var wire 32 l instr_instruction [31:0] $end
$var wire 8 m instr_read_address [7:0] $end
$var wire 1 * rst $end
$upscope $end
$scope module mux_alusrc $end
$var wire 32 n datain1 [31:0] $end
$var wire 32 o datain2 [31:0] $end
$var wire 1 B select_in $end
$var wire 32 p data_out [31:0] $end
$upscope $end
$scope module mux_branch $end
$var wire 32 q datain2 [31:0] $end
$var wire 1 - select_in $end
$var wire 32 r datain1 [31:0] $end
$var wire 32 s data_out [31:0] $end
$upscope $end
$scope module mux_reg_dst $end
$var wire 32 t datain1 [31:0] $end
$var wire 32 u datain2 [31:0] $end
$var wire 1 4 select_in $end
$var wire 32 v data_out [31:0] $end
$upscope $end
$scope module mux_to_reg $end
$var wire 32 w datain1 [31:0] $end
$var wire 32 x datain2 [31:0] $end
$var wire 1 ; select_in $end
$var wire 32 y data_out [31:0] $end
$upscope $end
$scope module pc_add $end
$var wire 4 z alu_control_in [3:0] $end
$var wire 32 { channel_a_in [31:0] $end
$var wire 32 | channel_b_in [31:0] $end
$var reg 32 } alu_result_out [31:0] $end
$var reg 32 ~ temp [31:0] $end
$var reg 1 !" zero_out $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0!"
b100 ~
b100 }
b100 |
b0 {
b10 z
bx y
bx x
bx w
b10 v
b0 u
b10 t
b100 s
b100 r
b100011 q
b11111 p
b11111 o
bx n
b0 m
b10001100000000100000000000011111 l
bx k
bx j
bx i
1h
b0 g
b100011 f
b10 e
b0 d
b11111 c
0b
b100011 a
b100011 `
b100 _
b11111 ^
b10 ]
bx \
bx [
b10 Z
b11111 Y
bx X
bx W
bx V
b10 U
b10 T
b0 S
bx R
bx Q
b0 P
b100 O
1N
bx M
b10 L
bx K
b10 J
bx I
b0 H
b0 G
b100011 F
b0 E
b10 D
bx C
1B
b11111 A
0@
b100011 ?
b11111 >
b10001100000000100000000000011111 =
bx <
1;
0:
b100 9
b0 8
b100 7
bx 6
bx 5
04
13
bx 2
b10 1
b0 0
b10 /
x.
0-
b0 ,
b0 +
1*
0)
b100011 (
b0 '
b0 &
bx %
b10 $
bx #
b10 "
bx !
$end
#50000
b101101001 !
b101101001 M
b0 #
b0 K
b0 %
b0 I
b101101001 2
b101101001 V
b101101001 y
b101101001 <
b101101001 j
b101101001 x
b11111 i
0.
b11111 C
b11111 [
b11111 w
b11111 \
b0 5
b0 R
b0 k
b0 n
b0 6
b0 Q
b0 X
b100000 W
1)
#100000
0*
0)
#105000
b10101110 !
b10101110 M
b11 "
b11 L
b11 $
b11 J
b0 #
b0 K
b100 '
b100 G
b10101110 2
b10101110 V
b10101110 y
b10101110 <
b10101110 j
b10101110 x
b100000 i
b100000 C
b100000 [
b100000 w
b100000 \
b11 U
b100000 A
b100000 Y
b100000 p
b11 /
b11 v
b1000 9
b1000 O
b1000 s
b101000 ?
b101000 `
b101000 q
b101000 a
b100000 c
b11 T
b100000 >
b100000 ^
b100000 o
b11 t
b11 1
b1000 7
b1000 _
b1000 r
b1000 }
b1000 ~
b10001100000000110000000000100000 =
b10001100000000110000000000100000 l
b1 m
b100 8
b100 P
b100 {
b0 5
b0 R
b0 k
b0 n
1)
#110000
0)
#115000
b1000010111 !
b1000010111 M
b100 "
b100 L
b101101001 %
b101101001 I
b10 &
b10 H
b0 (
b0 F
b10101110 #
b10101110 K
b1000 '
b1000 G
b100 U
b0 <
b0 j
b0 x
b10111 i
b100 /
b100 v
b1000010111 2
b1000010111 V
b1000010111 y
b1000010111 C
b1000010111 [
b1000010111 w
b1000010111 \
b10 E
b10 d
b10 g
14
13
0B
0;
0h
b10101110 A
b10101110 Y
b10101110 p
b1100 9
b1100 O
b1100 s
b10000000101100 ?
b10000000101100 `
b10000000101100 q
b10000000101100 a
b101101001 6
b101101001 Q
b101101001 X
b10 S
b0 f
b10000000100000 >
b10000000100000 ^
b10000000100000 o
b100 u
b100 0
b1100 7
b1100 _
b1100 r
b1100 }
b1100 ~
b10000110010000000100000 =
b10000110010000000100000 l
b10 m
b1000 8
b1000 P
b1000 {
b10101110 5
b10101110 R
b10101110 k
b10101110 n
1)
#116000
b1 +
b1 ,
#120000
0)
#125000
b111001101 !
b111001101 M
b100 "
b100 L
b1000010111 #
b1000010111 K
b100 $
b100 J
b1000 (
b1000 F
b1100 '
b1100 G
b111001101 2
b111001101 V
b111001101 y
b11001101 i
b111001101 C
b111001101 [
b111001101 w
b111001101 \
b100 U
b1100100 A
b1100100 Y
b1100100 p
1B
13
b0 E
b0 d
b0 g
04
b100 /
b100 v
b10000 9
b10000 O
b10000 s
b1110100 ?
b1110100 `
b1110100 q
b1110100 a
b100100 c
b1000010111 5
b1000010111 R
b1000010111 k
b1000010111 n
b100 T
b1000 f
b1100100 >
b1100100 ^
b1100100 o
b0 u
b0 0
b100 t
b100 1
b10000 7
b10000 _
b10000 r
b10000 }
b10000 ~
b100000010001000000000001100100 =
b100000010001000000000001100100 l
b11 m
b1100 8
b1100 P
b1100 {
1)
#126000
b10 +
b10 ,
